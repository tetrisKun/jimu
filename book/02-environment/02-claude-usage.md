# 2.2 Claude Sonnet 4 的使用方法

本节将介绍作为 AITDD 核心的 Claude Sonnet 4 的有效使用方法。我们将学习如何通过人机协作开发高质量软件,而不仅仅是让 AI 编写代码。

## Claude Sonnet 4 的特点和优势

### 在 AITDD 中的定位
- **Red-Green-Refactor-Validation 循环的执行主体**
- **从设计到测试、实现的一贯负责**
- **兼顾高质量代码生成和质量检查**

### 选择理由
- **可访问性**: 可在 Claude Code 中自由使用
- **编码性能**: 必要且充分的稳定性能
- **成本效益**: 合理的成本水平($20/月)
- **AITDD 适配性**: 最适合注重试错的开发风格
- **集成性**: 与 VS Code 环境的出色集成

## Claude Code 的基本使用方法

### 启动与基本操作

1. **启动 Claude Code**
   ```bash
   # 在 VS Code 中启动 Claude Code
   # 或通过浏览器版 Claude 访问
   ```

2. **与项目的集成**
   - 指定项目目录
   - 识别文件结构
   - 理解现有代码

### AITDD 中的基本对话模式

#### 1. 目标设定阶段
```
你: "我想实现用户管理功能的 CRUD 操作。请先创建 TODO 列表。"

Claude: "我将为用户管理功能创建 TODO 列表:
1. 定义用户模型
2. 创建用户创建功能的测试用例
3. 实现用户创建功能
..."
```

#### 2. 测试创建阶段
```
你: "请创建 TODO 第一项的测试用例。"

Claude: "我将创建用户模型的测试用例:
```javascript
describe('User Model', () => {
  test('should create user with valid data', () => {
    // 测试代码
  });
});
```"
```

#### 3. 实现阶段
```
你: "请实现能通过此测试的代码。"

Claude: "我将实现能通过测试的用户模型:
```javascript
class User {
  constructor(name, email) {
    // 实现代码
  }
}
```"
```

## 有效的提示词设计

### 提示词设计的基本原则

#### 1. 明确的目标设定
**好的例子:**
```
"我想实现用户注册 API (POST /users)。
- 包含验证功能
- 包含错误处理
- 希望以测试优先的方式进行"
```

**不好的例子:**
```
"创建用户功能"
```

#### 2. 提供上下文
```
"当前项目结构:
- Express.js + MongoDB
- Jest for testing
- 已有 User 模型

想要添加的新功能:
- 用户个人资料更新 API"
```

#### 3. 明确约束条件
```
"约束条件:
- 保持与现有 API 的兼容性
- 考虑安全性的实现
- 性能要求: 1 秒内响应"
```

### 提示词优化的迭代过程

#### 步骤1: 首次执行
1. **创建提示词**
2. **请求 AI 执行**
3. **评估结果**

#### 步骤2: 评估与改进
1. **识别与期望的差异**
2. **分析提示词的问题**
3. **设计改进版提示词**

#### 步骤3: 重新执行
1. **用改进后的提示词执行**
2. **确认改进程度**
3. **根据需要进一步调整**

### 实用的提示词模板

#### 功能实现模板
```
【实现请求】
功能: [具体功能名称]
技术栈: [使用技术列表]
要求:
- [要求1]
- [要求2]
- [要求3]

约束:
- [约束1]
- [约束2]

期望的交付物:
- 测试用例
- 实现代码
- 文档(如有必要)
```

#### 调试模板
```
【调试请求】
问题: [具体问题描述]
错误信息: [实际错误]
重现步骤:
1. [步骤1]
2. [步骤2]
3. [步骤3]

相关代码: [有问题的代码]
期望行为: [正常行为]
```

## 审查与质量管理

### 人工审查要点

#### 1. 与规格的一致性确认
- **设计意图的反映**: 计划的功能是否正确实现
- **需求覆盖**: 是否满足所有需求
- **约束遵守**: 是否遵守设定的约束

#### 2. 审查对象的优先级
1. **规格书**: 与需求的一致性最重要
2. **测试用例**: 规格的适当覆盖
3. **实现代码**: 代码质量和规格符合性

#### 3. 审查检查清单
- [ ] 是否满足功能需求
- [ ] 错误处理是否适当
- [ ] 是否考虑了安全需求
- [ ] 是否满足性能需求
- [ ] 测试覆盖率是否充分
- [ ] 代码的可读性和可维护性是否良好

### AI 未产生预期结果时的应对方法

#### 回退策略

**基本应对流程:**
1. **git reset**: 返回到之前的状态
2. **调整提示词**: 明确化和详细化指令
3. **重新执行**: 使用相同工具(Claude Sonnet 4)重试
4. **评估**: 确认改进程度

**git reset 的时机:**
- 最终代码与期望偏差较大时
- 判断重新开始比修正更快时
- 多次修正尝试未见改善时

#### 提示词调整技巧

**提高具体性:**
```
# 改进前
"修改这段代码"

# 改进后
"修改这段代码的以下问题:
1. 验证错误未得到适当处理
2. 返回值类型与规格不同
3. 边界情况测试不足"
```

**添加上下文:**
```
# 改进前
"创建 API"

# 改进后
"使用 Express.js 创建 RESTful API:
- 端点: POST /api/users
- 请求格式: JSON
- 响应格式: JSON
- 使用现有的 User 模型
- 已连接 MongoDB Atlas"
```

## 为持续改进而记录

### 记录成功模式
```markdown
## 成功案例记录

### 日期: 2025-06-21
### 任务: 用户认证 API 实现
### 使用的提示词:
[具体提示词内容]

### 结果:
- 一次性完成预期实现
- 测试也 100% 通过

### 经验:
- 认证系统指定具体库很有效
- 事先明示安全需求很重要
```

### 失败模式分析
```markdown
## 改进案例记录

### 日期: 2025-06-21
### 任务: 复杂查询优化
### 问题:
- 初始实现未满足性能要求
- 3 次修正尝试仍未改善

### 解决方案:
- 使用 git reset 返回初始状态
- 在提示词中用数值明示性能要求
- 提供参考实现示例

### 经验:
- 性能要求要定量指定
- 复杂任务要小块分割
```

## 与 Claude Sonnet 4 以外工具的配合使用

### 与 Gemini(用于调研)的详细协作

#### Gemini 的使用场景和优势
**使用场景:**
- 新库的调研
- 大量技术文档的读取
- 需要长上下文的调研任务
- 多信息源的信息整合

**Gemini 的独特优势:**
- **长上下文**: 可一次处理大量信息
- **信息收集能力**: 有效整合多个来源的信息
- **调研专精**: 在技术信息深入挖掘方面性能优秀

#### 实践协作工作流

**基本协作模式:**
```
1. 确定调研课题 → Gemini 进行信息收集
2. 整理和总结信息 → Gemini 进行分析
3. 制定实现计划 → 向 Claude Sonnet 4 提供信息
4. 执行 AITDD → Claude Sonnet 4 进行一致的实现
```

**协作的具体示例:**

**示例1: 引入新框架**
```
Gemini:
"请调研 Next.js 14 的新功能,整理从现有 Express.js
应用迁移的方法"

↓ 将调研结果提供给 Claude Sonnet 4

Claude Sonnet 4:
"基于 Gemini 的调研结果,创建分阶段迁移计划的 TODO 列表,
并使用 AITDD 实现第一个功能"
```

**示例2: 技术规格的深入调研**
```
Gemini:
"请调研 OAuth 2.0 和 JWT 认证组合的安全性
最佳实践和实现模式"

↓ 整理安全需求并提供给 Claude Sonnet 4

Claude Sonnet 4:
"基于调研结果,先创建安全认证系统的测试用例,
然后使用 AITDD 方法实现"
```

#### 使用场景判断标准

**应使用 Gemini 的场景:**
- [ ] 新技术、新库的初次调研
- [ ] 需要比较多个选项
- [ ] 需要读取长篇技术文档
- [ ] 需要整理复杂需求
- [ ] 需要调研先例

**应使用 Claude Sonnet 4 的场景:**
- [ ] 具体的实现工作
- [ ] 测试用例的创建
- [ ] 代码审查和质量检查
- [ ] 调试和故障排除
- [ ] 重构工作

### 实践运用技巧

#### 提示词设计的高级技巧

**上下文延续技术:**
```
# 会话开始时
"请记住以下项目结构:
- Express.js + MongoDB + Jest
- 已实现用户认证功能
- 本次目标: 添加用户个人资料管理功能"

# 在后续会话中引用
"基于之前告知的项目结构,
请创建个人资料更新 API 的测试用例"
```

**渐进式细化技术:**
```
# 阶段1: 概览级别
"请思考用户管理系统的整体设计"

# 阶段2: 功能级别
"从之前的设计出发,请创建个人资料更新功能的详细规格"

# 阶段3: 实现级别
"基于规格,请实现测试用例和 API 端点"
```

#### 错误应对的高级策略

**提示词调整模式分析:**

**模式1: 因缺乏具体性而失败**
```
# 失败示例
"创建 API"
→ 实现与期望大不相同

# 成功示例
"使用 Express.js 创建 POST /api/users/profile API:
- 请求: {name, email, bio}
- 验证: email 格式, name 必填
- 响应: 更新后的用户信息
- 错误处理: 对应 400, 401, 500"
```

**模式2: 因未指定技术约束而失败**
```
# 失败示例
"编写数据库操作代码"
→ 使用了未使用的 ORM 实现

# 成功示例
"使用 Mongoose 7.x 实现 User 模式的更新操作:
- 使用现有的 User 模型
- 使用 findByIdAndUpdate 方法
- 适当处理验证错误"
```

**提示词调整实践检查清单:**
- [ ] 明示使用的技术栈
- [ ] 具体指定输入输出格式
- [ ] 指示考虑错误情况
- [ ] 确保与现有代码的一致性
- [ ] 明示性能要求
- [ ] 指示安全性考虑事项

#### 持续改进的记录方法

**成功模式的模板化:**
```markdown
## 提示词模板: API 实现

### 基本格式
"使用[框架名]实现[HTTP方法] [端点] API:
- 请求格式: [详情]
- 响应格式: [详情]
- 验证: [要求]
- 错误处理: [对应的状态码]
- 使用现有的[模型名]模型"

### 应用示例
[具体使用示例]

### 预期结果
[成功时的输出模式]
```

**失败模式的分析记录:**
```markdown
## 改进记录: [日期]

### 有问题的提示词
[原提示词]

### 发生的问题
- [具体问题1]
- [具体问题2]

### 改进后的提示词
[修正版提示词]

### 改进要点
- [改进点1]
- [改进点2]

### 今后的应用指南
[如何应用到其他案例]
```

### 与其他 AI 工具比较的详情

**为什么要集中使用 Claude Sonnet 4:**

**1. 一致性的重要性**
- 使用同一工具的统一方法
- 学习的优化能累积发挥效果
- 对工具特有习惯和限制的应对会积累

**2. 学习效率的最大化**
- 精通一个工具可提高效率
- 提示词设计技巧深化
- 错误模式和应对方法积累

**3. 成本管理的简化**
- 单一工具比多工具更易管理
- 预算规划简化
- 使用量监控集中化

**4. 回退策略的简洁性**
- 可避免复杂的判断逻辑
- 无需判断"用哪个工具重试"
- 可快速解决问题

**工具集成的优势:**
```
项目                     集成方法    多工具方法
─────────────────────────────────────────────────────
学习成本                 低          高
提示词优化效率           高          低
成本管理复杂度           低          高
回退判断                 简单        复杂
知识积累效率             高          分散
─────────────────────────────────────────────────────
总体开发效率             优化        低效
```

### AI 工具环境的未来应对

#### 新技术的应对方针
**评估标准的体系化:**
- **性能评估**: 在现有工作流中的性能比较
- **成本分析**: 总拥有成本(含学习成本)评估
- **集成性评估**: 与当前开发环境的兼容性
- **迁移成本**: 工具变更相关成本的估算

**分阶段引入方法:**
1. **信息收集期**: 3-6 个月的观察期
2. **小规模测试**: 在非重要项目中试用
3. **比较评估**: 定量的性能和效率比较
4. **分阶段迁移**: 确认明确优势后谨慎迁移

**判断的定量化:**
```
新工具采用阈值:
- 性能提升: 20% 以上
- 成本降低: 15% 以上
- 学习成本: 2 周以内
- 集成成本: 当前工具的 50% 以下
```

## 下一步

了解了 Claude Sonnet 4 的使用方法后,请在下一章"2.3 开发环境和工作流构建"中构建实践 AITDD 的综合开发环境。我们将建立从 TODO 管理到 Git 工作流的系统化开发过程。
