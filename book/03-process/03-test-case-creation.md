# 3.3 测试用例创建

## 测试用例创建的重要性

在AITDD中,测试用例是决定实现质量的重要因素。AI生成代码的质量很大程度上依赖于测试用例的覆盖性和精度,因此在这个阶段设计全面的测试用例非常重要。

## 测试用例设计原则

### 1. 确保覆盖性

#### 功能的覆盖性
- **正常流程**: 所有预期的行为
- **异常流程**: 错误处理和验证
- **边界值**: 输入值的边界条件
- **边缘情况**: 特殊条件或异常情况

#### 测试级别的覆盖性
- **单元测试**: 单个函数/方法的测试
- **集成测试**: 组件间协作的测试
- **端到端测试**: 用户场景的完整执行

### 2. 明确且具体的期望值

```markdown
❌ 不好的例子:"发生错误"
✅ 好的例子:"返回状态码400和错误消息'Email already exists'"
```

### 3. 独立性和可重现性
- 每个测试用例可以独立执行
- 不依赖测试执行顺序
- 不依赖外部环境

## 测试用例文档的标准格式

### 基本模板

```markdown
# [功能名] 测试用例规格书

## 测试概要
- **测试对象**: 测试对象的功能名
- **测试目的**: 要验证什么
- **前提条件**: 测试执行的前提

## 测试用例列表

### TC001: [测试用例名]
- **分类**: 正常流程/异常流程/边界值
- **目的**: 本测试要验证的内容
- **前提条件**: 测试执行前的状态
- **测试数据**: 输入数据的详细信息
- **执行步骤**:
  1. 具体步骤1
  2. 具体步骤2
- **期望结果**:
  - 期望的行为详细说明
  - 期望的输出值
- **后置条件**: 测试执行后的期望状态
```

### 具体的测试用例示例

#### 例:用户注册功能的测试用例

```markdown
# 用户注册功能 测试用例规格书

## 测试概要
- **测试对象**: 用户新注册API (POST /api/users)
- **测试目的**: 验证新用户注册的所有模式
- **前提条件**: 数据库处于初始状态,API服务器运行中

## 测试用例列表

### TC001: 正常的用户注册
- **分类**: 正常流程
- **目的**: 验证使用有效数据进行新用户注册
- **前提条件**: test@example.com 未注册
- **测试数据**:
  ```json
  {
    "email": "test@example.com",
    "password": "SecurePass123!",
    "password_confirmation": "SecurePass123!"
  }
  ```
- **执行步骤**:
  1. 向POST /api/users发送测试数据
  2. 确认响应
  3. 确认数据库状态
- **期望结果**:
  - 状态码: 201
  - 响应:
    ```json
    {
      "id": 任意正整数,
      "email": "test@example.com",
      "created_at": "日期时间(ISO8601格式)"
    }
    ```
  - 数据库: 在users表中创建新记录
  - 密码被哈希化后保存
- **后置条件**: 用户正常注册,可以登录

### TC002: 邮箱地址重复错误
- **分类**: 异常流程
- **目的**: 验证使用已存在邮箱注册时的错误处理
- **前提条件**: test@example.com 已经注册
- **测试数据**:
  ```json
  {
    "email": "test@example.com",
    "password": "AnotherPass456!",
    "password_confirmation": "AnotherPass456!"
  }
  ```
- **执行步骤**:
  1. 向POST /api/users发送测试数据
  2. 确认响应
  3. 确认数据库状态
- **期望结果**:
  - 状态码: 400
  - 响应:
    ```json
    {
      "error": "validation_failed",
      "details": [
        {
          "field": "email",
          "message": "Email already exists"
        }
      ]
    }
    ```
  - 数据库: 不创建新记录
- **后置条件**: 现有用户数据无影响

### TC003: 密码不一致错误
- **分类**: 异常流程
- **目的**: 验证密码与确认密码不一致时的错误处理
- **前提条件**: 使用新邮箱地址
- **测试数据**:
  ```json
  {
    "email": "new@example.com",
    "password": "SecurePass123!",
    "password_confirmation": "DifferentPass456!"
  }
  ```
- **期望结果**:
  - 状态码: 400
  - 错误消息: "Password confirmation does not match"

### TC004: 无效的邮箱地址格式
- **分类**: 异常流程·边界值
- **目的**: 验证邮箱地址格式验证
- **测试数据集**:
  - "invalid-email" (没有@)
  - "test@" (没有域名部分)
  - "@example.com" (没有本地部分)
  - "test..test@example.com" (连续点)
- **期望结果**: 所有都返回400错误

### TC005: 密码强度不足
- **分类**: 异常流程·边界值
- **目的**: 验证密码强度验证
- **测试数据集**:
  - "short" (少于8字符)
  - "onlylowercase" (仅小写字母)
  - "ONLYUPPERCASE" (仅大写字母)
  - "12345678" (仅数字)
  - "NoSymbol123" (无符号)
- **期望结果**: 所有都返回400错误

### TC006: 必填项未输入
- **分类**: 异常流程
- **目的**: 验证必填项的验证
- **测试数据集**:
  - 无email
  - 无password
  - 无password_confirmation
  - 空字符串的情况
  - null的情况
- **期望结果**: 所有都返回400错误

### TC007: 边界值测试 - 邮箱地址长度
- **分类**: 边界值
- **目的**: 验证邮箱地址的字符数限制
- **测试数据**:
  - 254字符(最大允许)
  - 255字符(超过限制)
- **期望结果**:
  - 254字符: 正常注册
  - 255字符: 400错误

### TC008: 速率限制测试
- **分类**: 非功能
- **目的**: 验证同时注册的速率限制
- **执行步骤**: 短时间内发送大量请求
- **期望结果**: 超过限制时返回429错误

### TC009: 数据库连接错误
- **分类**: 异常流程·基础设施
- **目的**: 验证数据库故障时的行为
- **前提条件**: 数据库不可用
- **期望结果**: 500错误和错误日志输出

### TC010: CSRF令牌验证
- **分类**: 安全
- **目的**: 验证CSRF攻击的防护
- **测试数据**: 无CSRF令牌,或无效的令牌
- **期望结果**: 403错误
```

## 测试用例创建的工作流程

### 1. 从规格书提取测试用例

```markdown
规格书的各项目 → 对应的测试用例

■ 功能需求
- 基本功能 → 正常流程测试用例
- 验证 → 异常流程测试用例
- 输入限制 → 边界值测试用例

■ 非功能需求
- 性能 → 负载测试用例
- 安全 → 安全测试用例
- 可用性 → 故障测试用例
```

### 2. 测试用例设计的步骤

#### 步骤1: 整理测试观点
```markdown
## 测试观点列表

### 功能观点
- [ ] 正常输入下的行为
- [ ] 输入值验证
- [ ] 错误处理
- [ ] 数据持久化

### 数据观点
- [ ] 边界值(最小、最大)
- [ ] 特殊字符·多语言
- [ ] NULL·空字符
- [ ] 不正确的格式

### 状态观点
- [ ] 初始状态
- [ ] 数据存在状态
- [ ] 错误状态
- [ ] 限制状态

### 环境观点
- [ ] 正常环境
- [ ] 高负载环境
- [ ] 故障环境
```

#### 步骤2: 创建测试用例矩阵

| 功能 | 正常流程 | 异常流程 | 边界值 | 安全 | 性能 |
|------|--------|--------|--------|--------------|----------------|
| 用户注册 | TC001 | TC002-006 | TC007 | TC010 | TC008 |
| 验证 | - | TC002-006 | TC004,005,007 | - | - |
| 数据保存 | TC001 | TC009 | - | - | - |

#### 步骤3: 创建详细测试用例
- 将各单元格的内容展开为详细的测试用例
- 落实为可执行的具体步骤
- 明确定义期望结果

### 3. 利用AI支持测试用例

#### AI可以活用的领域
- **覆盖性检查**: 指出遗漏的测试用例
- **测试数据生成**: 建议边界值和异常值
- **期望值计算**: 计算复杂的计算结果
- **测试用例结构化**: 统一格式

#### 人类应该判断的领域
- **业务需求的理解**: 领域特定的要求
- **风险评估**: 影响度和重要度的判定
- **测试优先级**: 执行顺序和资源分配
- **质量标准**: 验收标准的设定

## 测试用例质量的检查要点

### 1. 完整性确认

#### 功能覆盖率
```markdown
## 覆盖率检查清单

### API规格书的各项目
- [ ] 所有端点都有测试用例
- [ ] 所有参数都有测试用例
- [ ] 所有响应模式都有测试用例

### 错误处理
- [ ] 所有错误代码都有测试用例
- [ ] 所有验证规则都有测试用例
- [ ] 所有异常模式都有测试用例
```

#### 业务规则覆盖率
```markdown
### 业务规则验证
- [ ] 所有业务流程都有测试用例
- [ ] 所有业务异常都有测试用例
- [ ] 所有权限模式都有测试用例
```

### 2. 可执行性确认

#### 测试数据的可准备性
- 能否准备必要的测试数据
- 能否模拟外部依赖服务
- 能否在测试环境中执行

#### 期望结果的可验证性
- 期望结果能否客观判定
- 验证所需的工具或方法是否可用
- 难以自动化部分的手工确认方法

### 3. 可维护性确认

#### 测试用例的独立性
- 每个测试用例可以独立执行
- 不依赖测试顺序
- 可以并行执行

#### 对变更的应对
- 规格变更时影响范围明确
- 测试用例的修改容易
- 测试数据的管理简单

## 人工审查要点

### 审查观点

#### 1. 与业务需求的一致性
- [ ] 用户故事是否得到适当测试
- [ ] 业务规则是否正确反映
- [ ] 边缘情况从业务角度是否妥当

#### 2. 基于风险的优先级
- [ ] 高风险功能是否有足够的测试用例
- [ ] 重要业务流程是否被覆盖
- [ ] 安全要求是否得到适当测试

#### 3. 测试效率性
- [ ] 测试用例数是否适当(不过多/不过少)
- [ ] 是否有重复的测试用例
- [ ] 可自动化部分与手工测试的分离是否适当

### 审查流程

#### 步骤1: 初步审查
- 确认与规格书的一致性
- 覆盖性的基本检查
- 指出明显的遗漏或问题

#### 步骤2: 详细审查
- 确认各测试用例的妥当性
- 确认期望结果的正确性
- 验证可执行性

#### 步骤3: 最终批准
- 确认整体质量
- 确认测试执行计划
- 判定进入下一阶段

## 测试用例创建的最佳实践

### 1. 阶段性详细化

```markdown
第1阶段: 概要级别
"测试用户注册的正常流程·异常流程"

第2阶段: 功能级别
"有效数据的注册成功"
"无效数据的注册失败"

第3阶段: 详细级别
"TC001: 正常的用户注册"
"TC002: 邮箱地址重复错误"
```

### 2. 测试数据的战略性设计

#### 数据模式的体系化
```markdown
## 基本数据集
- 正常数据: 一般的有效值
- 边界数据: 限制值(最小/最大)
- 异常数据: 无效值·不正确值
- 特殊数据: 特殊字符·多语言·NULL
```

#### 可重用的测试数据
- 定义通用使用的测试数据
- 管理测试数据的变体
- 自动化数据创建

### 3. 精确定义期望结果

#### 具体的期望值
```markdown
❌ "发生错误"
✅ "HTTP 400 + {"error": "validation_failed", "field": "email"}"

❌ "正常注册"
✅ "HTTP 201 + 返回用户ID + 在DB中创建记录"
```

#### 可验证的条件
- 输出值的具体值或格式
- 数据库的状态变化
- 日志输出的内容
- 对外部系统的影响

## 常见问题和对策

### 问题1: 测试用例的粒度不适当

**症状**:
- 一个测试用例测试多个功能
- 相反,过于细致导致管理成本高

**对策**:
- 1个测试用例 = 1个验证观点
- 按照有业务价值的单位分组

### 问题2: 期望结果模糊

**症状**:
- "正常工作""发生错误"等
- 判定标准不明确

**对策**:
- 明确记载具体的值或状态
- 意识到自动测试的判定条件

### 问题3: 测试用例遗漏

**症状**:
- 未考虑边缘情况
- 错误模式不足

**对策**:
- 通过检查清单进行系统确认
- 活用等价类划分和边界值分析

### 问题4: 可维护性不足

**症状**:
- 规格变更时测试用例修改困难
- 测试数据的管理繁琐

**对策**:
- 模块化设计
- 可重用的测试数据设计

## 为下一步做准备

测试用例创建完成后,进入下一步[Red-Green-Refactor-Validation循环](./04-rgr-validation-cycle.md)。

### 交付物确认
- [ ] testcases.md已详细创建
- [ ] 所有规格项目都对应测试用例
- [ ] 期望结果已具体定义
- [ ] 人工审查已完成
- [ ] 测试数据可以准备

### 质量检查清单
- [ ] **覆盖性**: 正常流程·异常流程·边界值已覆盖
- [ ] **明确性**: 期望结果具体且可验证
- [ ] **独立性**: 各测试用例可以独立执行
- [ ] **可实现性**: 可在测试环境中执行
- [ ] **可维护性**: 易于应对规格变更的结构

通过适当的测试用例创建,为AI生成高质量代码奠定了基础。下一章将详细解说基于这些测试用例的实现循环。
