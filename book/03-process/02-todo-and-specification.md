# 3.2 TODO创建和需求定义

## TODO创建:开发的起点

### TODO的重要性

在AITDD中,适当的TODO创建是成功的关键。模糊的TODO会对之后的所有步骤产生不良影响,因此创建明确且可执行的TODO非常重要。

### 有效TODO创建的原则

#### 1. 确保具体性
```markdown
❌ 不好的例子:"创建用户管理功能"
✅ 好的例子:"实现用户新注册功能(email/password认证)"
```

#### 2. 适当的粒度
- **太大**: 一个TODO包含多个功能
- **太小**: 单个方法级别
- **适当**: 一个完整的功能单元

#### 3. 明确完成条件
```markdown
## TODO: 用户注册API实现

### 完成条件
- [ ] POST /api/users 端点的实现
- [ ] email/password的验证
- [ ] 密码哈希化
- [ ] 数据库保存
- [ ] 响应格式的统一
```

### TODO管理文件的结构

#### 基本格式

```markdown
# 项目 TODO管理

## 待实现
### 高优先级
- [ ] **用户认证功能**
  - 说明: 基于JWT认证的认证功能
  - 完成条件: 登录/登出/令牌验证
  - 依赖: 数据库设计完成

### 中优先级
- [ ] **商品搜索功能**
  - 说明: 通过关键词和类别进行商品搜索
  - 完成条件: 搜索API + 过滤功能

## 进行中
- [x] 数据库设计(2024-06-21 完成)

## 已完成
- [x] 项目初始设置(2024-06-20 完成)
```

#### 文件构成的推荐事项

```
docs/
├── todo.md                                # 主TODO管理
├── implements/
│    ├──TASK-101/
│    │  ├── user-auth-requirements.md    # 各功能的详细规格
│    │  └── user-auth-testcases.md       # 测试用例
│    └──TASK-201/
│        └── search-requirements.md
└── archive/
    └── completed-todos.md                # 已完成TODO的归档
```

## 需求定义:设计的基础

### 需求定义的目的

从TODO制定具体的技术规格,明确实现的方向。这个阶段的模糊性会在后续步骤中成为大问题,因此详细考虑很重要。

### 需求文档的模板

```markdown
# [功能名] 需求定义书

## 概要
简洁描述功能的目的和概要

## 功能需求

### 基本功能
- 必须的基本功能

### 详细规格
- 输入项目和验证
- 处理流程
- 输出格式

### 非功能需求
- 性能要求
- 安全要求
- 可用性要求

## 技术规格

### API规格
- 端点
- 请求/响应格式
- 状态码

### 数据库设计
- 表设计
- 索引
- 约束

### 错误处理
- 错误情况的定义
- 错误消息
- 日志输出方针

## 约束条件
- 技术约束
- 业务约束
- 外部依赖

## 参考资料
- 相关文档
- 外部API规格书
```

### 具体的需求定义示例

#### 例:用户注册功能的规格

```markdown
# 用户注册功能 需求定义书

## 概要
新用户可以通过email和password注册的功能

## 功能需求

### 基本功能
- 通过email/password进行新用户注册
- 验证重复email
- 密码强度检查

### 详细规格

#### 输入项目
- **email**: 必填,email格式,最大254字符
- **password**: 必填,8字符以上,包含字母数字符号
- **password_confirmation**: 必填,与password一致

#### 验证
- email重复检查(数据库确认)
- password强度(包含大小写/数字/符号)
- CSRF令牌验证

#### 处理流程
1. 输入值验证
2. email重复检查
3. password哈希化(bcrypt)
4. 数据库保存
5. 返回成功响应

### 非功能需求
- 响应时间: 2秒以内
- 同时注册: 支持最多100件/秒
- 密码哈希化必须

## 技术规格

### API规格
```http
POST /api/users
Content-Type: application/json

Request:
{
  "email": "user@example.com",
  "password": "SecurePass123!",
  "password_confirmation": "SecurePass123!"
}

Response (201):
{
  "id": 123,
  "email": "user@example.com",
  "created_at": "2024-06-21T10:00:00Z"
}

Response (400):
{
  "error": "validation_failed",
  "details": [
    {
      "field": "email",
      "message": "Email already exists"
    }
  ]
}
```

### 数据库设计
```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(254) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
```

### 错误处理
- **400**: 验证错误,重复email
- **429**: 速率限制
- **500**: 服务器错误

## 约束条件
- 禁止明文存储密码
- 本次不包含email确认功能
- 本次不包含社交登录
```

## 人工审查要点

### 检查项目

#### 1. 完整性确认
- [ ] 是否包含所有必要功能
- [ ] 是否考虑边缘情况
- [ ] 错误处理是否充分

#### 2. 可行性验证
- [ ] 技术上是否可实现
- [ ] 性能要求是否现实
- [ ] 安全要求是否适当

#### 3. 一致性确认
- [ ] 与其他功能的一致性
- [ ] 数据设计的一致性
- [ ] API接口的统一性

#### 4. 可维护性考虑
- [ ] 未来的扩展性
- [ ] 测试的易用性
- [ ] 文档化的容易程度

### 审查时的注意事项

#### 利用AI建议时的注意
- AI的建议作为参考使用
- 最终判断必须由人工做出
- 项目特有的要求由人工添加

#### 阶段性详细化
```
1. 概要级别的规格 → 审查
2. 详细规格的追加 → 审查
3. 技术规格的制定 → 审查
4. 最终确认 → 批准
```

## 需求定义的最佳实践

### 1. 明确且无歧义的表述
```markdown
❌ "适当处理"
✅ "出错时返回400状态码和错误消息"
```

### 2. 明确具体数值
```markdown
❌ "高速处理"
✅ "2秒以内返回响应"
```

### 3. 明确约束条件
```markdown
❌ "考虑安全性"
✅ "密码用bcrypt哈希化,禁止明文保存"
```

### 4. 考虑可测试性
- 确认各规格项目是否可测试
- 考虑测试数据的准备方法
- 考虑mock和stub的必要性

## 为下一步做准备

需求定义完成后,进入下一步[测试用例创建](./03-test-case-creation.md)。

### 交付物确认
- [ ] TODO.md已适当更新
- [ ] requirements.md已详细创建
- [ ] 规格中没有模糊部分
- [ ] 人工审查已完成

### 常见问题和对策

#### 规格模糊就继续进行
**对策**: 必须实施人工审查,现场解决疑问

#### 过度依赖AI的建议
**对策**: AI的建议仅作参考,最终判断由人工做出

#### 遗漏非功能需求
**对策**: 使用检查清单进行系统审查

通过适当的需求定义,后续的测试用例创建和实现将会顺利进行。
